import { supabase } from '../lib/supabase';

export const ticketService = {
  async getTickets(options = {}) {
    const { 
      search = '', 
      status = 'all', 
      category = 'all', 
      sortBy = 'recent',
      offset = 0,
      limit = 50 
    } = options

    let query = supabase?.from('tickets')?.select(`
        *,
        user_profile:user_profiles!tickets_user_id_fkey(full_name, email),
        assigned_agent:user_profiles!tickets_assigned_agent_id_fkey(full_name, email),
        comments:ticket_comments(count),
        upvotes:ticket_upvotes(count)
      `)

    // Apply filters
    if (search) {
      query = query?.or(`title.ilike.%${search}%,description.ilike.%${search}%,ticket_number.ilike.%${search}%`)
    }
    
    if (status !== 'all') {
      query = query?.eq('status', status)
    }
    
    if (category !== 'all') {
      query = query?.eq('category', category)
    }

    // Apply sorting
    switch (sortBy) {
      case 'recent':
        query = query?.order('last_modified', { ascending: false })
        break
      case 'oldest':
        query = query?.order('created_at', { ascending: true })
        break
      case 'upvoted':
        query = query?.order('upvotes', { ascending: false })
        break
      case 'commented':
        // This requires a more complex query, simplified for now
        query = query?.order('last_modified', { ascending: false })
        break
      default:
        query = query?.order('last_modified', { ascending: false })
    }

    query = query?.range(offset, offset + limit - 1)

    const { data, error } = await query
    
    if (error) throw error
    
    // Transform the data to match expected format
    return data?.map(ticket => ({
      ...ticket,
      commentCount: ticket?.comments?.[0]?.count || 0,
      upvoteCount: ticket?.upvotes?.[0]?.count || 0,
      assignedAgent: ticket?.assigned_agent?.full_name || null,
      createdBy: ticket?.user_profile?.full_name || ticket?.user_profile?.email
    })) || []
  },

  async getTicketById(ticketId) {
    const { data, error } = await supabase?.from('tickets')?.select(`
        *,
        user_profile:user_profiles!tickets_user_id_fkey(full_name, email, avatar_url),
        assigned_agent:user_profiles!tickets_assigned_agent_id_fkey(full_name, email, avatar_url),
        comments:ticket_comments(
          *,
          user_profile:user_profiles(full_name, email, avatar_url)
        )
      `)?.eq('id', ticketId)?.single()

    if (error) throw error
    return data
  },

  async createTicket(ticketData) {
    const { data, error } = await supabase?.from('tickets')?.insert([{
        ...ticketData,
        ticket_number: null // Will be generated by trigger
      }])?.select()?.single()

    if (error) throw error
    return data
  },

  async updateTicket(ticketId, updates) {
    const { data, error } = await supabase?.from('tickets')?.update(updates)?.eq('id', ticketId)?.select()?.single()

    if (error) throw error
    return data
  },

  async deleteTicket(ticketId) {
    const { error } = await supabase?.from('tickets')?.delete()?.eq('id', ticketId)

    if (error) throw error
  },

  async addComment(ticketId, content, commentType = 'comment') {
    const { data, error } = await supabase?.from('ticket_comments')?.insert([{
        ticket_id: ticketId,
        content,
        comment_type: commentType,
        user_id: (await supabase?.auth?.getUser())?.data?.user?.id
      }])?.select(`
        *,
        user_profile:user_profiles(full_name, email, avatar_url)
      `)?.single()

    if (error) throw error
    return data
  },

  async toggleUpvote(ticketId) {
    const user = await supabase?.auth?.getUser()
    if (!user?.data?.user) throw new Error('Not authenticated')

    const userId = user?.data?.user?.id

    // Check if already upvoted
    const { data: existingUpvote } = await supabase?.from('ticket_upvotes')?.select('id')?.eq('ticket_id', ticketId)?.eq('user_id', userId)?.single()

    if (existingUpvote) {
      // Remove upvote
      const { error: deleteError } = await supabase?.from('ticket_upvotes')?.delete()?.eq('ticket_id', ticketId)?.eq('user_id', userId)

      if (deleteError) throw deleteError

      // Decrement upvotes count
      const { error: updateError } = await supabase?.from('tickets')?.update({ upvotes: supabase?.sql`upvotes - 1` })?.eq('id', ticketId)

      if (updateError) throw updateError
      
      return { upvoted: false }
    } else {
      // Add upvote
      const { error: insertError } = await supabase?.from('ticket_upvotes')?.insert([{
          ticket_id: ticketId,
          user_id: userId
        }])

      if (insertError) throw insertError

      // Increment upvotes count
      const { error: updateError } = await supabase?.from('tickets')?.update({ upvotes: supabase.sql`upvotes + 1` })?.eq('id', ticketId)

      if (updateError) throw updateError

      return { upvoted: true }
    }
  },

  async getTicketStats() {
    const { data, error } = await supabase?.from('tickets')?.select('status')

    if (error) throw error

    const stats = data?.reduce((acc, ticket) => {
      acc.total = (acc?.total || 0) + 1
      const status = ticket?.status?.toLowerCase()
      acc[status] = (acc?.[status] || 0) + 1
      return acc
    }, {}) || {}

    return {
      total: stats?.total || 0,
      open: stats?.open || 0,
      in_progress: stats?.in_progress || 0,
      resolved: stats?.resolved || 0,
      closed: stats?.closed || 0
    };
  },

  async checkUserUpvote(ticketId, userId) {
    const { data, error } = await supabase?.from('ticket_upvotes')?.select('id')?.eq('ticket_id', ticketId)?.eq('user_id', userId)?.single()

    if (error && error?.code !== 'PGRST116') throw error
    return !!data
  }
}